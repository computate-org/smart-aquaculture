---
# Source: overpass-api/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: overpass-api-sa
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
---
# Source: overpass-api/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: overpass-api-scripts
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
data:
  init_overpass.sh: |
    #!/bin/bash

    set -e

    OVERPASS_DB_DIR="/app/db"
    OVERPASS_DIFF_DIR="/app/diffs"
    WORK_DIR="/app/work"

    # Define the log function with log levels
    log() {
      local level="$1"
      shift
      echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] - $*" >&2
    }

    # Function to display available disk space
    display_disk_space() {
      local path="$1"
      local space
      space=$(df -h "${path}" | awk 'NR==2 {print $4}')
      log "INFO" "Available disk space at ${path}: ${space}"
    }

    # Function to monitor disk space periodically
    monitor_disk_space() {
      while true; do
        display_disk_space "${OVERPASS_DB_DIR}"
        sleep 60
      done
    }

    # Function to download the planet file
    download_planet_file() {
      local file_name
      file_name=$(basename "$OVERPASS_PLANET_URL")
      local planet_file="${WORK_DIR}/${file_name}"

      log "INFO" "Downloading planet file: ${file_name}"

      wget -nv --show-progress --progress=dot -e dotbytes=30M -O "${planet_file}" "$OVERPASS_PLANET_URL"

      if [ ! -f "${planet_file}" ]; then
        log "ERROR" "Failed to download ${file_name}"
        exit 1
      fi

      echo "${planet_file}"
    }

    # Function to prepare the initialization file
    prepare_init_file() {
      local planet_file="$1"

      if [ ! -f "${planet_file}" ]; then
        log "ERROR" "Planet file not found: ${planet_file}"
        exit 1
      fi

      if [[ "$planet_file" == *.osm.pbf ]]; then
        log "INFO" "Converting PBF to BZ2 format using osmium with progress..."
        local osm_file="${WORK_DIR}/planet.osm.bz2"

        # Check if osmium is available
        if ! command -v osmium >/dev/null 2>&1; then
          log "ERROR" "osmium command not found. Please install osmium."
          exit 1
        fi

        osmium cat "${planet_file}" -o "${osm_file}" --verbose --overwrite

        if [ ! -f "${osm_file}" ]; then
          log "ERROR" "OSM file not created: ${osm_file}"
          exit 1
        fi

        echo "${osm_file}"
      elif [[ "$planet_file" == *.osm.bz2 ]]; then
        log "INFO" "Using bz2 file directly..."
        echo "${planet_file}"
      else
        log "ERROR" "Unsupported file format: ${planet_file}"
        exit 1
      fi
    }

    cleanup_files() {
      local planet_file="$1"
      local init_file="$2"

      rm -f "${planet_file}"
      [ "${planet_file}" != "${init_file}" ] && rm -f "${init_file}"
    }

    # Function to initialize the database
    initialize_database() {
      if [ ! -f "$OVERPASS_DB_DIR/replicate_id" ]; then
        log "INFO" "Initializing database..."
        mkdir -p "$OVERPASS_DB_DIR" "$OVERPASS_DIFF_DIR" "$WORK_DIR"

        display_disk_space "${WORK_DIR}"

        local planet_file
        planet_file=$(download_planet_file)
        log "INFO" "Downloaded file: ${planet_file}"

        display_disk_space "${WORK_DIR}"

        local init_file
        init_file=$(prepare_init_file "${planet_file}")
        log "INFO" "Prepared file: ${init_file}"

        display_disk_space "${WORK_DIR}"

        if [ ! -f "${init_file}" ]; then
          log "ERROR" "Prepared file not found: ${init_file}"
          exit 1
        fi

        log "INFO" "Initializing Overpass database with file: ${init_file}"

        display_disk_space "${OVERPASS_DB_DIR}"

        # Temporarily disable 'set -e' to capture errors
        set +e

        # Start background disk space monitoring
        monitor_disk_space &
        disk_monitor_pid=$!

        # Run the database initialization script
        /app/osm-3s/bin/init_osm3s.sh "${init_file}" "$OVERPASS_DB_DIR" "/app/osm-3s" \
          --meta --compression-method="$OVERPASS_COMPRESSION"

        exit_status=$?

        # Stop disk space monitoring
        kill "$disk_monitor_pid"

        set -e

        if [ $exit_status -ne 0 ]; then
          log "ERROR" "init_osm3s.sh failed with exit status $exit_status. Exiting."
          sleep 5
          exit $exit_status
        fi

        cleanup_files "${planet_file}" "${init_file}"

        display_disk_space "${WORK_DIR}"

        log "INFO" "Database initialization complete."
      else
        log "INFO" "Database already initialized."
      fi
    }

    main() {
      initialize_database
    }

    main


  run_overpass.sh: |
    #!/bin/bash

    set -e

    OVERPASS_DB_DIR="/app/db"
    OVERPASS_DIFF_DIR="/app/diffs"
    cp -r /app/osm-3s_v0.7.55/rules/ /app/db/rules/

    # Define the log function with log levels
    log() {
      local level="$1"
      shift
      echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] - $*" >&2
    }

    start_api_and_updates() {
      log "INFO" "Starting Overpass API and update processes..."

      /app/osm-3s/bin/dispatcher --osm-base --meta --db-dir="${OVERPASS_DB_DIR#/app/}" &

      # Start the continuous update process
      log "INFO" "Starting fetch_osc.sh..."
      /app/osm-3s/bin/fetch_osc.sh "$OVERPASS_UPDATE_FREQUENCY" "$OVERPASS_DIFF_URL" "${OVERPASS_DIFF_DIR#/app/}" &

      log "INFO" "Starting apply_osc_to_db.sh..."
      /app/osm-3s/bin/apply_osc_to_db.sh "${OVERPASS_DIFF_DIR#/app/}" "$OVERPASS_UPDATE_FREQUENCY" --meta &

      log "INFO" "Starting rules_loop.sh..."
      /app/osm-3s/bin/rules_loop.sh "${OVERPASS_DB_DIR#/app/}" "$OVERPASS_RULES_LOAD" &

      log "INFO" "Configuring and starting fcgiwrap..."
      sed -i "s/FCGI_CHILDREN=.*/FCGI_CHILDREN=$OVERPASS_FASTCGI_PROCESSES/" /etc/init.d/fcgiwrap
      service fcgiwrap start

      log "INFO" "Configuring Overpass settings..."
      echo "$OVERPASS_RATE_LIMIT" > "$OVERPASS_DB_DIR/rate_limit"
      echo "$OVERPASS_TIME" > "$OVERPASS_DB_DIR/max_allowed_time"
      echo "$OVERPASS_SPACE" > "$OVERPASS_DB_DIR/max_allowed_space"
      echo "$OVERPASS_MAX_TIMEOUT" > "$OVERPASS_DB_DIR/max_allowed_timeout"

      log "INFO" "Starting nginx..."
      nginx -g 'daemon off;'
    }

    main() {
      start_api_and_updates
    }

    main

  health_check.sh: |
    #!/bin/bash

    # Credits to https://github.com/wiktorn/Overpass-API/blob/master/docker-healthcheck.sh

    set -e -o pipefail

    NODE_ID=1

    # Define the log function with log levels
    log() {
      local level="$1"
      shift
      echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] - $*" >&2
    }

    # if we allow duplicate queries, the healthcheck will fail because it always fetches node id 1
    # if that is the case (default), we query a random node
    if [[ ! -n ${OVERPASS_ALLOW_DUPLICATE_QUERIES} || ${OVERPASS_ALLOW_DUPLICATE_QUERIES} == "no" ]]; then
      NODE_ID=$(shuf -i 1-10000000 -n 1)
    fi

    OVERPASS_HEALTHCHECK='curl --noproxy "*" -qf "http://localhost/api/interpreter?data=\[out:json\];node(${NODE_ID});out;" | jq ".generator" |grep -q Overpass || exit 1'

    # Perform the health check
    if eval "${OVERPASS_HEALTHCHECK}"; then
      log "INFO" "Health check passed."
      exit 0
    else
      log "ERROR" "Health check failed."
      exit 1
    fi
---
# Source: overpass-api/templates/serviceaccount.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: overpass-api-role
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
rules:
- apiGroups: [""]
  resources: ["persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["batch"]
  resources: ["jobs"]
  verbs: ["get", "list", "watch"]
---
# Source: overpass-api/templates/serviceaccount.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: overpass-api-rolebinding
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
subjects:
- kind: ServiceAccount
  name: overpass-api-sa
roleRef:
  kind: Role
  name: overpass-api-role
  apiGroup: rbac.authorization.k8s.io
---
# Source: overpass-api/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: overpass-api
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
---
# Source: overpass-api/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: overpass-api
  labels:
    helm.sh/chart: overpass-api-0.5.15
    app.kubernetes.io/name: overpass-api
    app.kubernetes.io/instance: overpass-api
    app.kubernetes.io/version: "0.7.62.8"
    app.kubernetes.io/managed-by: Helm
spec:
  serviceName: overpass-api
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: overpass-api
      app.kubernetes.io/instance: overpass-api
  template:
    metadata:
      labels:
        app.kubernetes.io/name: overpass-api
        app.kubernetes.io/instance: overpass-api
    spec:
      serviceAccountName: overpass-api-sa
      # initContainers:
      #   - name: init-overpass-data
      #     #image: "remikalbe/overpass-api-kube:0.7.62.8"
      #     image: "quay.io/computate/overpass-api-kube:openshift"
      #     imagePullPolicy: IfNotPresent
      #     command:
      #       - /bin/bash
      #       - /scripts/init_overpass.sh
      #     volumeMounts:
      #     - name: data
      #       mountPath: /app/db
      #     - name: data
      #       mountPath: /app/work
      #     - name: data
      #       mountPath: /app/diffs
      #     - name: scripts
      #       mountPath: /scripts
      #     env:
      #     - name: OVERPASS_PLANET_URL
      #       value: "https://download.geofabrik.de/north-america/us/louisiana-latest.osm.pbf"
      #     - name: OVERPASS_META
      #       value: "yes"
      #     - name: OVERPASS_COMPRESSION
      #       value: "gz"
      containers:
        - name: overpass-api
          #image: "remikalbe/overpass-api-kube:0.7.62.8"
          # image: "quay.io/computate/overpass-api-kube:openshift"
          image: docker.io/wiktorn/overpass-api
          imagePullPolicy: IfNotPresent
          env:
          - name: OVERPASS_META
            value: "yes"
          - name: OVERPASS_MODE
            value: "init"
          - name: OVERPASS_PLANET_URL
            value: "http://download.geofabrik.de/north-america/us/louisiana-latest.osm.bz2-disabled"
          - name: OVERPASS_DIFF_URL
            value: "http://download.openstreetmap.fr/replication/north-america/us-south/minute"
          - name: OVERPASS_RULES_LOAD
            value: "10"
#          - name: OVERPASS_RATE_LIMIT
#            value: "1024"
#          - name: OVERPASS_TIME
#            value: "1000"
#          - name: OVERPASS_SPACE
#            value: "5.36870912e+08"
#          - name: OVERPASS_MAX_TIMEOUT
#            value: "1000"
#          - name: OVERPASS_UPDATE_FREQUENCY
#            value: "minute"
#          - name: OVERPASS_COMPRESSION
#            value: "gz"
#          - name: OVERPASS_ALLOW_DUPLICATE_QUERIES
#            value: "no"
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          volumeMounts:
          - name: db
            mountPath: /db
          # readinessProbe:
          #   exec:
          #     command:
          #       - /bin/bash
          #       - /app/docker-healthcheck.sh
          #   initialDelaySeconds: 30
          #   periodSeconds: 10
          #   timeoutSeconds: 5
          #   failureThreshold: 3000
          # livenessProbe:
          #   exec:
          #     command:
          #       - /bin/bash
          #       - /app/docker-healthcheck.sh
          #   initialDelaySeconds: 60
          #   periodSeconds: 15
          #   timeoutSeconds: 5
          #   failureThreshold: 3
          resources:
            limits:
              cpu: 1
              memory: 8Gi
            requests:
              cpu: 500m
              memory: 1Gi
      volumes:
      - name: scripts
        configMap:
          name: overpass-api-scripts
          defaultMode: 0755
  volumeClaimTemplates:
  - metadata:
      name: db
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "crc-csi-hostpath-provisioner"
      resources:
        requests:
          storage: "100Gi"
